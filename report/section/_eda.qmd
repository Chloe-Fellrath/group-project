# EDA

## Univariate Analysis
In this step, each key variable is examined individually to understand its distribution, central tendency, and overall spread. This approach helps us identify important characteristics such as skewness, outliers, common categories, and temporal patterns.
By analyzing variables one at a time, we gain a clearer view of how each behaves independently before exploring relationships between them. For our project, we focus on four main variables—track_popularity, genre, gender, and release_year—as they form the foundation of our subsequent analyses.
Examining these variables separately allows us to highlight meaningful patterns, detect irregularities, and better justify the methodological choices we make in the later stages of the study.
```{python}
##Loading the data set for an overview of the dataset
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

sns.set_theme(style="whitegrid", context="notebook",
                palette="colorblind", font_scale=1.1")

df = pd.read_csv("cleaned_final_dataset.csv")

df.head() # shows the first 5 rows of the dataset
df.tail() # shows the 5 last rows preview
df.shape # shows the dimension of the dataset
df.dtypes # check the structure of the data
df.isna().sum() # check if there is some missing value (no missing values found)
```
Since the dataset is complete, we can proceed directly with feature-level analysis and explore patterns in musical characteristics.
## Overview of the key variables
To recall we have chosen 4 key variables that will help us through our analysis:
- track_popularity: integer
- genre: string
- gender: string
- release_year: integer

## Distribution Plots
### Distribution of popularity
```{python}
#| label: fig-performance-dist
#| fig-cap: "Distribution of performance scores showing approximately normal distribution"
# Set publication-quality style
sns.set_theme(style="whitegrid", context="notebook",
              palette="colorblind", font_scale=1.1)
plt.figure(figsize=(10,5))
sns.histplot(df["track_popularity"], kde=True, bins=30)
plt.title("Distribution of track popularity scores")
plt.xlabel("Popularity")
plt.ylabel("Count")
plt.show()
```
The distribution of track popularity is noticeably right-skewed, as shown in the histogram. Although our dataset focuses on songs that were considered popular (Billboard Hot year-end charts) from the 1960s to today, many tracks now receive very low popularity scores (between 0 and 10).
This pattern reflects how Spotify calculates popularity: it is not based on historical success, but on current listening activity. As a result, older tracks that were once widely recognized may no longer be frequently streamed, leading to low popularity values today.
This skewness highlights an important limitation of the variable: popularity on Spotify captures present-day relevance, not long-term cultural impact. This will be important to consider when interpreting trends over time or comparing older and newer releases.
### Distribution of genre
```{python}
import matplotlib.pyplot as plt
import pandas as pd

df = pd.read_csv("../data/processed/cleaned_final_dataset.csv")

def map_genre(genre):
    if pd.isna(genre) or str(genre).strip().lower() in ["n/a", "unknown", ""]:
        return None  # Remove unknowns
    if "rock" in genre:
        return "Rock"
    if "pop" in genre or "christmas" in genre:
        return "Pop"
    if "hip hop" in genre or "hip-hop" in genre or "rap" in genre:
        return "Hip-Hop/Rap"
    if "edm" in genre or "electronic" in genre or "electro" in genre or "new wave" in genre or "synth" in genre:
        return "Electronic/Synth"
    if "jazz" in genre or "motown" in genre or "northern soul" in genre or "new jack swing" in genre:
        return "Jazz"
    if "metal" in genre:
        return "Metal"
    if "folk" in genre or "country" in genre:
        return "Country"
    if "r&b" in genre or "soul" in genre or "doo-wop" in genre or "doowop" in genre:
        return "R&B/Soul"
    if "unknown" in genre:
        return "Unknown"
    return "Other"

# Apply grouping
df["genre_grouped"] = df["genre"].apply(map_genre)
# Count frequencies
genre_counts = df["genre_grouped"].value_counts()

plt.figure(figsize=(10, 6))
plt.bar(genre_counts.index, genre_counts.values)   # shows the barplots
plt.xticks(rotation=45, ha="right")
plt.title("Genre Distribution")
plt.xlabel("Genre")
plt.ylabel("Count")
plt.tight_layout()
plt.show()
```
In this plot, all songs with unknown or ambiguous genres have been removed for clearer interpretation. We grouped all genres into the most frequent categories to better understand trends, excluding less common or unclassified genres.
The visualization highlights the most popular genres across decades, showing, for example, the prominence of Rock and the rise of Pop and Hip-Hop/Rap later on, offering interesting analysis insights to look into how music tastes have evolved over time.
### Distribution of gender
The gender distribution contains four categories: male, female, group, non-binary, and unknown. The male and female categories represent individual artists whose gender information is explicitly provided. The unknown category corresponds to missing or incomplete entries, which mainly come from inconsistencies in the MusicBrainz API.
This highlights a data limitation: gender information is not always available for every artist, especially older or less documented ones. The group category refers to musical groups or bands; these may consist of only men, only women, or mixed members. We chose not to classify groups further by internal composition, as this would require additional assumptions and introduce classification uncertainty.
Finally, the non-binary category represents a very small proportion of the dataset. This reflects both the relatively recent visibility of non-binary artists in mainstream music databases and the historical lack of representation in the industry. Overall, this distribution illustrates both structural biases in data collection and broader social dynamics within the music industry.
```{python}
sns.set_theme(style="whitegrid", context="notebook",
              palette="colorblind", font_scale=1.1)
plt.figure(figsize=(8,5))
sns.countplot(data=df, x="gender")
plt.title("Distribution of gender")
plt.xlabel("Gender category")
plt.ylabel("Count")
plt.show()
```
This missing gender information must be acknowledged because it affects the interpretation of all gender-related analyses. Any comparison between male, female, non-binary, and group artists will be biased if ‘unknown’ forms such a large segment.
For this reason, descriptive statistics and statistical tests should be conducted both including and excluding the ‘unknown’ category, depending on the research question.
```{python}
# Filter only men and women
df_binary_gender = df[df["gender"].isin(["male", "female"])]

sns.set_theme(style="whitegrid", context="notebook",
              palette="colorblind", font_scale=1.1)

plt.figure(figsize=(8,5))
sns.countplot(data=df_binary_gender, x="gender")
plt.title("Distribution of Gender (Men vs Women Solo Artists Only)")
plt.xlabel("Gender")
plt.ylabel("Count")
plt.show()
```
For this additional visualization, we filtered the dataset to include only male and female solo-artists in order to observe the distribution between these two majority groups.
Entries labeled “unknown” or “non-binary” were excluded from this plot but are still considered in the global analysis.

###Distribution of the release year
```{python}
plt.figure(figsize=(10,5))
sns.histplot(df["release_year"], bins=5)
plt.title("Distribution of release years")
plt.xlabel("Release year")
plt.ylabel("Count")
plt.show()
```
The distribution of release years shows a clear decline in the number of tracks originating from earlier decades, particularly from the 1960s to the early 1980s. Part of this decline is due to missing values introduced during our standardisation and cleaning process, where inconsistent or non-numeric year formats could not be reliably converted and therefore became “unknown” (represented as 0) in the dataset.
Additionally, Spotify’s API does not always provide a release year for older recordings, especially for tracks that were digitized, reissued, or remastered multiple times. In cases of remastered editions, the available release year may refer to the reissue date rather than the original publication year, creating additional uncertainty in the dataset.
Consequently, the temporal distribution should be interpreted with caution, as the representation of earlier decades is incomplete and may not accurately reflect the true musical output of those periods.
To facilitate clearer temporal analysis, we create a new variable grouping tracks by decade, which smooths out year-to-year inconsistencies.
```{python}
##Distribution of decades
# Create decade variable from release_year
df["decade"] = (df["release_year"] // 10) * 10

# Convert to string labels (e.g., "1960s")
df["decade"] = df["decade"].astype(int).astype(str) + "s"

# Check distribution
df["decade"].value_counts().sort_index()

# Visualization of the plot
plt.figure(figsize=(10,5))
sns.countplot(data=df, x="decade", order=sorted(df["decade"].unique()))
plt.title("Distribution of Tracks by Decade")
plt.xlabel("Decade")
plt.ylabel("Count")
plt.show()
```
::: {.panel-tabset}

## Summary Statistics
The summary statistics provide an overview of our key variables. Numeric variables (release_year and popularity) reveal central tendencies, spread, skewness, and potential outliers.
Categorical variables (genre and gender) show the distribution of categories (see distribution above) and highlight the most common groups. Box plots and bar plots complement the statistics, making it easier to visualize distribution patterns and understand the dataset at a glance.
```{python}
#| label: tbl-summary-stats
#| tbl-cap: "Summary statistics for performance scores"
# Code visibility controlled by format settings in report.qmd

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

df = pd.read_csv("cleaned_final_dataset.csv")
key_vars = ["release_year", "genre", "gender", "popularity"]

for var in key_vars:
    print(f"\n=== Summary Statistics for {var} ===")

    if df[var].dtype in ["int64", "float64"]:
        # Numeric variables
        summary_stats = df[var].describe()
        print(summary_stats.to_string())
        print(f"Skewness: {df[var].skew():.3f}")
        print(f"Kurtosis: {df[var].kurtosis():.3f}")
    else:
        # Categorical variables
        counts = df[var].value_counts()
        print("\nCounts:")
        print(counts.to_string())
        print(f"Unique categories: {df[var].nunique()}")

# BOX PLOT FOR NUMERIC VARIABLES
numeric_vars = ["release_year", "popularity"]

for var in numeric_vars:
    fig, ax = plt.subplots(figsize=(6, 4))

    bp = ax.boxplot(df[var].dropna(), vert=True, patch_artist=True,
                    labels=[var],
                    boxprops=dict(facecolor='lightblue', edgecolor='black', linewidth=1.5),
                    medianprops=dict(color='red', linewidth=2),
                    whiskerprops=dict(color='black', linewidth=1.5),
                    capprops=dict(color='black', linewidth=1.5))

    ax.set_title(f"{var} Distribution (Box Plot)", fontsize=13, fontweight='bold', pad=15)
    ax.set_ylabel(var, fontsize=11)
    ax.grid(True, axis='y', alpha=0.3, linestyle='--')

    plt.tight_layout()
    plt.show()
```
:::

# Bivariate Analysis

After examining each variable individually, we now explore how they relate to each other.  
In particular, we focus on:

- how gender representation changes across decades,  
- how gender is distributed across genres, and  
- how popularity varies across gender categories.

These relationships are central to our research question:  
**How has the diversity of artists evolved in top charts over time, and how is it reflected across genres and popularity levels?**
Our research focuses on relationships between:
- gender × decade
- gender × genre
- gender × popularity
- popularity × release year

These help evaluate how gender representation and popularity metrics evolve across time and musical categories.
::: 

## Gender Distribution Across Decades
```{python}
#| label: fig-gender-decade
#| fig-cap: "Gender distribution across decades"
df_decade_gender = df[df["gender"].isin(["male", "female", "non-binary"])]

plt.figure(figsize=(10, 5))
sns.countplot(
    data=df_decade_gender,
    x="decade",
    hue="gender",
    palette="colorblind"
)

plt.title("Gender Distribution Across Decades")
plt.xlabel("Decade")
plt.ylabel("Number of Tracks")
plt.xticks(rotation=45)
plt.legend(title="Gender")
plt.tight_layout()
plt.show()
```
Interpretation: As shown in @fig-gender-decade, gender representation in Billboard-charting tracks has changed substantially across decades. Male artists consistently dominate every decade, although the gap between male and female artists narrows noticeably starting in the 1980s. Female representation increases steadily from the 1980s onward, reaching its highest levels in the 2010s and 2020s.
Non-binary artists appear only in the most recent decades and remain extremely rare.

These patterns suggest that gender diversity in popular music has improved over time, but remains unequal.
The strong male dominance in earlier decades reflects historical industry barriers that limited female participation in mainstream music production and promotion.
The rise in female artists from the 1980s onward aligns with broader cultural and industry shifts—such as increased visibility, market demand, and improved professional opportunities for women.
The emergence of non-binary artists in the 2010s and 2020s likely reflects changing social norms, greater recognition of gender diversity, and improved availability of metadata documenting non-binary identities.

Implications for Our Research Questions
Has gender representation among charting artists become more diverse over time?
The increasing presence of female and non-binary artists supports the hypothesis that representation is improving, although the persistent male majority shpws that gender equality has not yet been achieved.

In the original dataset, a large number of artists had gender = "unknown" due to incomplete metadata from external sources. Including these entries would have made the chart difficult to interpret, because “Unknown” does not represent a gender category, but missing information. Its large size would artificially inflate some decades and hide real gender patterns. It would distort comparisons of gender proportions over time. Therefore, for this visualization, only male, female, and non-binary artists were included so that the plot accurately reflects trends among artists whose gender is known.

We will still acknowledge the presence of “unknown” in the limitations section, because missing gender information may bias the observed distribution.

## Gender Representation Across Top 10 Genres
```{python}
#| label: fig-gender-top-genres
#| fig-cap: "Gender Representation Across Top 10 Genres"
df_gender = df[df["gender"].isin(["male", "female", "non-binary"])]

df_gender = df_gender[df_gender["genre"] != "unknown"]

top_genres = df_gender["genre"].value_counts().head(10).index

df_top = df_gender[df_gender["genre"].isin(top_genres)]

plt.figure(figsize=(10, 5))
sns.countplot(data=df_top, x="genre", hue="gender", palette="colorblind")
plt.title("Gender Representation Across Top 10 Genres")
plt.xlabel("Genre")
plt.ylabel("Number of Tracks")
plt.xticks(rotation=45)
plt.legend(title="Gender")
plt.tight_layout()
plt.show()
```
Interpretation: As shown in @fig-gender-top-genres, the distribution of gender categories across the ten most frequent genres reveals clear patterns in representation. After removing the "unknown" category to avoid misleading proportions (because unknown entries come from missing metadata rather than meaningful gender categories), the visualization provides a cleaner and more interpretable picture of gender diversity in popular music genres.

Across nearly all top genres, male artists dominate, often making up the largest proportion of tracks within each genre.
Female artists appear consistently but in noticeably smaller numbers, and non-binary artists are extremely rare, appearing only in one or two genres with minimal counts. Some genres—such as pop and R&B—show a more balanced representation between male and female artists, while others—such as rap or rock—show a strong male majority.

The Story Behind the Pattern, these patterns reflect long-standing gender dynamics within the music industry:
- Male dominance in genres like rap and rock aligns with historical trends where these genres have been male-led spaces, often influenced by cultural norms and industry barriers.
- More balanced representation in pop and R&B suggests that these genres have traditionally offered more visibility and commercial opportunities for women.
The near absence of non-binary artists highlights both the recent recognition of non-binary identities and a lack of industry representation historically.

Understanding these disparities is essential for interpreting broader trends in artist visibility and chart success. If certain genres inherently skew male or female, then comparing gender representation without accounting for genre would give a distorted picture. This analysis shows that gender representation is genre-dependent, which we must consider in any follow-up statistical analyses—especially when examining popularity or career trends.

To make the analysis meaningful and avoid distortions, we restricted the visualization to the Top 10 most common genres in the dataset. Many genres outside the top 10 appear only a handful of times, which would introduce noise and make cross-gender comparisons unreliable. Additionally, we excluded the “unknown” genre category, since it reflects missing or incomplete metadata rather than a real musical classification. Removing these entries ensures that the chart focuses on genuine genre categories and provides a clearer, more interpretable picture of how gender representation varies across the most relevant segments of the dataset.

## Track Popularity by Gender Category
```{python}
df_gender = df[df["gender"].isin(["male", "female", "non-binary"])]

plt.figure(figsize=(10, 5))
sns.boxplot(data=df_gender, x="gender", y="track_popularity", palette="colorblind")
plt.title("Track Popularity by Gender Category")
plt.xlabel("Gender")
plt.ylabel("Track Popularity (0–100)")
plt.grid(axis='y', linestyle='--', alpha=0.4)
plt.tight_layout()
plt.show()
```
Interpretation: 

## Average Track Popularity Across Decades
```{python}
df_clean = df[(df["gender"].isin(["male", "female", "non-binary"])) &
              (df["release_year"] >= 1900)]

if "decade" not in df_clean.columns:
    df_clean["decade"] = (df_clean["release_year"] // 10) * 10

decade_popularity = df_clean.groupby("decade")["track_popularity"].mean().reset_index()

plt.figure(figsize=(10, 5))
sns.lineplot(data=decade_popularity, x="decade", y="track_popularity", marker="o")
plt.title("Average Track Popularity Across Decades")
plt.xlabel("Decade")
plt.ylabel("Average Popularity (0–100)")
plt.grid(axis='y', linestyle='--', alpha=0.4)
plt.tight_layout()
plt.show()
```
Interpretation: 

## Average Track Popularity by Gender Across Decades
```{python}
df_clean = df[(df["gender"].isin(["male", "female", "non-binary"])) &
              (df["release_year"] >= 1900)]

if "decade" not in df_clean.columns:
    df_clean["decade"] = (df_clean["release_year"] // 10) * 10

gender_decade_pop = (
    df_clean.groupby(["decade", "gender"])["track_popularity"]
    .mean()
    .reset_index()
)

plt.figure(figsize=(10, 5))
sns.lineplot(
    data=gender_decade_pop,
    x="decade",
    y="track_popularity",
    hue="gender",
    marker="o",
    palette="colorblind"
)

plt.title("Average Track Popularity by Gender Across Decades")
plt.xlabel("Decade")
plt.ylabel("Average Track Popularity")
plt.grid(axis="y", linestyle="--", alpha=0.4)
plt.tight_layout()
plt.show()
```
Interpretation: 

## Correlation Analysis (Numeric Variables)
- track_popularity
- duration_ms
- release_year
```{python}
numeric_df = df[["track_popularity", "duration_ms", "release_year"]]

corr = numeric_df.corr()

plt.figure(figsize=(7,6))
sns.heatmap(
    corr,
    annot=True,
    cmap="coolwarm",
    center=0,
    linewidths=0.5,
    fmt=".2f"
)
plt.title("Correlation Matrix of Numeric Variables", fontsize=14)
plt.tight_layout()
plt.show()
```
Interpretation: 

:::

## Key Findings
1. **Distribution patterns**: The performance scores shown in @fig-performance-dist follow an approximately normal distribution with a mean of `{python} f'{dummy_performance["performance"].mean():.2f}'` and standard deviation of `{python} f'{dummy_performance["performance"].std():.2f}'`.

   **Interpretation**: This normal distribution suggests that most students perform around the average, with fewer students at the extremes (very high or very low scores). The relatively small standard deviation indicates consistent performance across the group. This pattern is typical in educational settings and suggests that the assessment was well-calibrated meaning not too easy (which would cause ceiling effects) nor too difficult (which would cause floor effects). The normality assumption also validates the use of parametric statistical tests for subsequent analyses.

2. **Outliers and data quality**: The box plot (@fig-performance-box) reveals minimal outliers, with only a few observations falling below the lower whisker.

   **Interpretation**: The scarcity of outliers suggests good data quality and consistent measurement. The few low-performing outliers warrant further investigation - they could represent students who faced unusual circumstances or measurement errors. However, their small number means they are unlikely to significantly impact our overall conclusions. This finding gives us confidence in proceeding with the full dataset without extensive outlier removal.

3. **Group differences**: @fig-performance-by-instructor demonstrates noticeable variation in performance across different instructors, with some instructors showing higher median scores than others. The ANOVA test (@tbl-anova-test) confirms these differences are `{python} 'statistically significant (p < 0.05)' if p_value < 0.05 else 'not statistically significant (p ≥ 0.05)'`.

   **Interpretation**: `{python} 'The significant differences across instructors raise important questions about teaching effectiveness, grading consistency, or student assignment to sections. This finding suggests that "instructor" should be included as a control variable in any regression models predicting performance.' if p_value < 0.05 else 'The lack of significant differences suggests that instructor assignment does not substantially impact performance, or that grading standards are well-harmonized across sections.'` It also indicates that comparing students across different sections requires careful consideration. From a policy perspective, this might warrant investigating whether certain teaching methods are more effective or whether grading standards need to be harmonized across sections.

4. **Relationships**: The correlation matrix (@fig-correlation-matrix) reveals several interesting patterns:
   - Strong positive correlation (r = `{python} f'{corr_matrix.loc["Experience", "Salary"]:.2f}'`) between Experience and Salary
   - Moderate positive correlation (r = `{python} f'{corr_matrix.loc["Experience", "Performance"]:.2f}'`) between Experience and Performance
   - Weak correlation (r = `{python} f'{corr_matrix.loc["Age", "Performance"]:.2f}'`) between Age and Performance

   **Interpretation**: The Experience-Salary correlation aligns with economic theory that experience is rewarded in labor markets. The Experience-Performance correlation suggests that experience contributes to better performance, though other factors clearly matter as well. Interestingly, Age shows minimal correlation with Performance, suggesting that chronological age alone doesn't predict success - what matters is relevant experience. These patterns will guide our variable selection for predictive modeling, favoring Experience over Age as a key predictor.

5. **Experience-Performance relationship**: @fig-scatter-experience-performance clearly shows a positive linear relationship, with more experienced individuals tending to have higher performance scores. The correlation coefficient is `{python} f'{corr:.2f}'`.

   **Interpretation**: The linear relationship visible in the scatter plot confirms that experience has a consistent, positive effect on performance. However, the substantial scatter around the regression line indicates that experience alone doesn't determine performance - individual differences and other factors play important roles. This suggests that while experience is valuable, organizations shouldn't rely solely on it when making hiring or promotion decisions.

::: {.callout-warning}
## Common Mistakes in Interpretation

**Observation (not interpretation):** "The histogram shows a normal distribution."
**Why it's insufficient:** This only describes what you see - it's an observation, not an interpretation. You need to explain what it *means* and *why it matters*.

**Good interpretation (observation + story):** "The histogram shows a normal distribution (mean = 0.90, sd = 0.05), which indicates consistent performance across students. This pattern validates the use of parametric statistical tests in our subsequent analysis. The tight distribution suggests the assessment was well-calibrated, effectively distinguishing between ability levels without ceiling or floor effects that would compress scores."

:::
